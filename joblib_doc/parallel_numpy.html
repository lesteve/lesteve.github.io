<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Working with numerical data in shared memory (memmaping) &mdash; joblib 0.9.0.dev0 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.9.0.dev0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="joblib 0.9.0.dev0 documentation" href="index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="index.html">joblib 0.9.0.dev0 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="working-with-numerical-data-in-shared-memory-memmaping">
<h1>Working with numerical data in shared memory (memmaping)<a class="headerlink" href="#working-with-numerical-data-in-shared-memory-memmaping" title="Permalink to this headline">¶</a></h1>
<p>By default the workers of the pool are real Python processes forked using the
<tt class="docutils literal"><span class="pre">multiprocessing</span></tt> module of the Python standard library when <tt class="docutils literal"><span class="pre">n_jobs</span> <span class="pre">!=</span> <span class="pre">1</span></tt>.
The arguments passed as input to the <tt class="docutils literal"><span class="pre">Parallel</span></tt> call are serialized and
reallocated in the memory of each worker process.</p>
<p>This can be problematic for large arguments as they will be reallocated
<tt class="docutils literal"><span class="pre">n_jobs</span></tt> times by the workers.</p>
<p>As this problem can often occur in scientific computing with <tt class="docutils literal"><span class="pre">numpy</span></tt>
based datastructures, <a class="reference internal" href="parallel.html#joblib.Parallel" title="joblib.Parallel"><tt class="xref py py-class docutils literal"><span class="pre">joblib.Parallel</span></tt></a> provides a special
handling for large arrays to automatically dump them on the filesystem
and pass a reference to the worker to open them as memory map
on that file using the <tt class="docutils literal"><span class="pre">numpy.memmap</span></tt> subclass of <tt class="docutils literal"><span class="pre">numpy.ndarray</span></tt>.
This makes it possible to share a segment of data between all the
worker processes.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The following only applies with the default <tt class="docutils literal"><span class="pre">&quot;multiprocessing&quot;</span></tt> backend. If
your code can release the GIL, then using <tt class="docutils literal"><span class="pre">backend=&quot;threading&quot;</span></tt> is even
more efficient.</p>
</div>
<div class="section" id="automated-array-to-memmap-conversion">
<h2>Automated array to memmap conversion<a class="headerlink" href="#automated-array-to-memmap-conversion" title="Permalink to this headline">¶</a></h2>
<p>The automated array to memmap conversion is triggered by a configurable
threshold on the size of the array:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">joblib</span> <span class="kn">import</span> <span class="n">Parallel</span><span class="p">,</span> <span class="n">delayed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">joblib.pool</span> <span class="kn">import</span> <span class="n">has_shareable_memory</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">Parallel</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">max_nbytes</span><span class="o">=</span><span class="mf">1e6</span><span class="p">)(</span>
<span class="gp">... </span>    <span class="n">delayed</span><span class="p">(</span><span class="n">has_shareable_memory</span><span class="p">)(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">)))</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="mf">1e2</span><span class="p">,</span> <span class="mf">1e4</span><span class="p">,</span> <span class="mf">1e6</span><span class="p">])</span>
<span class="go">[False, False, True]</span>
</pre></div>
</div>
<p>By default the data is dumped to the <tt class="docutils literal"><span class="pre">/dev/shm</span></tt> shared-memory partition if it
exists and writeable (typically the case under Linux). Otherwise the operating
system&#8217;s temporary folder is used. The location of the temporary data files can
be customized by passing a <tt class="docutils literal"><span class="pre">temp_folder</span></tt> argument to the <tt class="docutils literal"><span class="pre">Parallel</span></tt>
constructor.</p>
<p>Passing <tt class="docutils literal"><span class="pre">max_nbytes=None</span></tt> makes it possible to disable the automated array to
memmap conversion.</p>
</div>
<div class="section" id="manual-management-of-memmaped-input-data">
<h2>Manual management of memmaped input data<a class="headerlink" href="#manual-management-of-memmaped-input-data" title="Permalink to this headline">¶</a></h2>
<p>For even finer tuning of the memory usage it is also possible to
dump the array as an memmap directly from the parent process to
free the memory before forking the worker processes. For instance
let&#8217;s allocate a large array in the memory of the parent process:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">large_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="mf">1e6</span><span class="p">))</span>
</pre></div>
</div>
<p>Dump it to a local file for memmaping:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">tempfile</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">os</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">joblib</span> <span class="kn">import</span> <span class="n">load</span><span class="p">,</span> <span class="n">dump</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">temp_folder</span> <span class="o">=</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">mkdtemp</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">filename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">temp_folder</span><span class="p">,</span> <span class="s">&#39;joblib_test.mmap&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span> <span class="n">os</span><span class="o">.</span><span class="n">unlink</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">_</span> <span class="o">=</span> <span class="n">dump</span><span class="p">(</span><span class="n">large_array</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">large_memmap</span> <span class="o">=</span> <span class="n">load</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">mmap_mode</span><span class="o">=</span><span class="s">&#39;r+&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">large_memmap</span></tt> variable is pointing to a <tt class="docutils literal"><span class="pre">numpy.memmap</span></tt>
instance:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">large_memmap</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span> <span class="n">large_array</span><span class="o">.</span><span class="n">nbytes</span><span class="p">,</span> <span class="n">large_array</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(&#39;memmap&#39;, 8000000, (1000000,))</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">large_array</span><span class="p">,</span> <span class="n">large_memmap</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>We can free the original array from the main process memory:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">large_array</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">gc</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">_</span> <span class="o">=</span> <span class="n">gc</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>
</pre></div>
</div>
<p>It it possible to slice <tt class="docutils literal"><span class="pre">large_memmap</span></tt> into a smaller memmap:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">small_memmap</span> <span class="o">=</span> <span class="n">large_memmap</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">small_memmap</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span> <span class="n">small_memmap</span><span class="o">.</span><span class="n">nbytes</span><span class="p">,</span> <span class="n">small_memmap</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(&#39;memmap&#39;, 24, (3,))</span>
</pre></div>
</div>
<p>Finally we can also take a <tt class="docutils literal"><span class="pre">np.ndarray</span></tt> view backed on that same
memory mapped file:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">small_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">small_memmap</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">small_array</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span> <span class="n">small_array</span><span class="o">.</span><span class="n">nbytes</span><span class="p">,</span> <span class="n">small_array</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(&#39;ndarray&#39;, 24, (3,))</span>
</pre></div>
</div>
<p>All those three datastructures point to the same memory buffer and
this same buffer will also be reused directly by the worker processes
of a <tt class="docutils literal"><span class="pre">Parallel</span></tt> call:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Parallel</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">max_nbytes</span><span class="o">=</span><span class="bp">None</span><span class="p">)(</span>
<span class="gp">... </span>    <span class="n">delayed</span><span class="p">(</span><span class="n">has_shareable_memory</span><span class="p">)(</span><span class="n">a</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="p">[</span><span class="n">large_memmap</span><span class="p">,</span> <span class="n">small_memmap</span><span class="p">,</span> <span class="n">small_array</span><span class="p">])</span>
<span class="go">[True, True, True]</span>
</pre></div>
</div>
<p>Note that here we used <tt class="docutils literal"><span class="pre">max_nbytes=None</span></tt> to disable the auto-dumping
feature of <tt class="docutils literal"><span class="pre">Parallel</span></tt>. The fact that <tt class="docutils literal"><span class="pre">small_array</span></tt> is still in
shared memory in the worker processes is a consequence of the fact
that it was already backed by shared memory in the parent process.
The pickling machinery of <tt class="docutils literal"><span class="pre">Parallel</span></tt> multiprocessing queues are
able to detect this situation and optimize it on the fly to limit
the number of memory copies.</p>
</div>
<div class="section" id="writing-parallel-computation-results-in-shared-memory">
<h2>Writing parallel computation results in shared memory<a class="headerlink" href="#writing-parallel-computation-results-in-shared-memory" title="Permalink to this headline">¶</a></h2>
<p>If you open your data using the <tt class="docutils literal"><span class="pre">w+</span></tt> or <tt class="docutils literal"><span class="pre">r+</span></tt> mode in the main program, the
worker will have <tt class="docutils literal"><span class="pre">r+</span></tt> mode access hence will be able to write results
directly to it alleviating the need to serialization to communicate back the
results to the parent process.</p>
<p>Here is an example script on parallel processing with preallocated
<tt class="docutils literal"><span class="pre">numpy.memmap</span></tt> datastructures:</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81</pre></div></td><td class="code"><div class="highlight"><pre><span class="sd">&quot;&quot;&quot;Demonstrate the usage of numpy.memmap with joblib.Parallel</span>

<span class="sd">This example shows how to preallocate data in memmap arrays both for input and</span>
<span class="sd">output of the parallel worker processes.</span>

<span class="sd">Sample output for this program::</span>

<span class="sd">    [Worker 93486] Sum for row 0 is -1599.756454</span>
<span class="sd">    [Worker 93487] Sum for row 1 is -243.253165</span>
<span class="sd">    [Worker 93488] Sum for row 3 is 610.201883</span>
<span class="sd">    [Worker 93489] Sum for row 2 is 187.982005</span>
<span class="sd">    [Worker 93489] Sum for row 7 is 326.381617</span>
<span class="sd">    [Worker 93486] Sum for row 4 is 137.324438</span>
<span class="sd">    [Worker 93489] Sum for row 8 is -198.225809</span>
<span class="sd">    [Worker 93487] Sum for row 5 is -1062.852066</span>
<span class="sd">    [Worker 93488] Sum for row 6 is 1666.334107</span>
<span class="sd">    [Worker 93486] Sum for row 9 is -463.711714</span>
<span class="sd">    Expected sums computed in the parent process:</span>
<span class="sd">    [-1599.75645426  -243.25316471   187.98200458   610.20188337   137.32443803</span>
<span class="sd">     -1062.85206633  1666.33410715   326.38161713  -198.22580876  -463.71171369]</span>
<span class="sd">    Actual sums computed by the worker processes:</span>
<span class="sd">    [-1599.75645426  -243.25316471   187.98200458   610.20188337   137.32443803</span>
<span class="sd">     -1062.85206633  1666.33410715   326.38161713  -198.22580876  -463.71171369]</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">tempfile</span>
<span class="kn">import</span> <span class="nn">shutil</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">joblib</span> <span class="kn">import</span> <span class="n">Parallel</span><span class="p">,</span> <span class="n">delayed</span>
<span class="kn">from</span> <span class="nn">joblib</span> <span class="kn">import</span> <span class="n">load</span><span class="p">,</span> <span class="n">dump</span>


<span class="k">def</span> <span class="nf">sum_row</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute the sum of a row in input and store it in output&quot;&quot;&quot;</span>
    <span class="n">sum_</span> <span class="o">=</span> <span class="nb">input</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&quot;[Worker </span><span class="si">%d</span><span class="s">] Sum for row </span><span class="si">%d</span><span class="s"> is </span><span class="si">%f</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">(),</span> <span class="n">i</span><span class="p">,</span> <span class="n">sum_</span><span class="p">))</span>
    <span class="n">output</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sum_</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
    <span class="n">folder</span> <span class="o">=</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">mkdtemp</span><span class="p">()</span>
    <span class="n">samples_name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">folder</span><span class="p">,</span> <span class="s">&#39;samples&#39;</span><span class="p">)</span>
    <span class="n">sums_name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">folder</span><span class="p">,</span> <span class="s">&#39;sums&#39;</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="c"># Generate some data and an allocate an output buffer</span>
        <span class="n">samples</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="mf">1e6</span><span class="p">)))</span>

        <span class="c"># Pre-allocate a writeable shared memory map as a container for the</span>
        <span class="c"># results of the parallel computation</span>
        <span class="n">sums</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">memmap</span><span class="p">(</span><span class="n">sums_name</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">samples</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
                         <span class="n">shape</span><span class="o">=</span><span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">mode</span><span class="o">=</span><span class="s">&#39;w+&#39;</span><span class="p">)</span>

        <span class="c"># Dump the input data to disk to free the memory</span>
        <span class="n">dump</span><span class="p">(</span><span class="n">samples</span><span class="p">,</span> <span class="n">samples_name</span><span class="p">)</span>

        <span class="c"># Release the reference on the original in memory array and replace it</span>
        <span class="c"># by a reference to the memmap array so that the garbage collector can</span>
        <span class="c"># release the memory before forking. gc.collect() is internally called</span>
        <span class="c"># in Parallel just before forking.</span>
        <span class="n">samples</span> <span class="o">=</span> <span class="n">load</span><span class="p">(</span><span class="n">samples_name</span><span class="p">,</span> <span class="n">mmap_mode</span><span class="o">=</span><span class="s">&#39;r&#39;</span><span class="p">)</span>

        <span class="c"># Fork the worker processes to perform computation concurrently</span>
        <span class="n">Parallel</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="mi">4</span><span class="p">)(</span><span class="n">delayed</span><span class="p">(</span><span class="n">sum_row</span><span class="p">)(</span><span class="n">samples</span><span class="p">,</span> <span class="n">sums</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
                           <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">samples</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

        <span class="c"># Compare the results from the output buffer with the ground truth</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&quot;Expected sums computed in the parent process:&quot;</span><span class="p">)</span>
        <span class="n">expected_result</span> <span class="o">=</span> <span class="n">samples</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="n">expected_result</span><span class="p">)</span>

        <span class="k">print</span><span class="p">(</span><span class="s">&quot;Actual sums computed by the worker processes:&quot;</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="n">sums</span><span class="p">)</span>

        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">expected_result</span><span class="p">,</span> <span class="n">sums</span><span class="p">)</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">shutil</span><span class="o">.</span><span class="n">rmtree</span><span class="p">(</span><span class="n">folder</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&quot;Failed to delete: &quot;</span> <span class="o">+</span> <span class="n">folder</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p>Having concurrent workers write on overlapping shared memory data segments,
for instance by using inplace operators and assignments on a <cite>numpy.memmap</cite>
instance, can lead to data corruption as numpy does not offer atomic
operations. The previous example does not risk that issue as each task is
updating an exclusive segment of the shared result array.</p>
<p class="last">Some C/C++ compilers offer lock-free atomic primitives such as add-and-fetch
or compare-and-swap that could be exposed to Python via <a class="reference external" href="https://cffi.readthedocs.org">CFFI</a> for instance.
However providing numpy-aware atomic constructs is outside of the scope
of the joblib project.</p>
</div>
<p>A final note: don&#8217;t forget to clean up any temporary folder when you are done
with the computation:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">shutil</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">shutil</span><span class="o">.</span><span class="n">rmtree</span><span class="p">(</span><span class="n">temp_folder</span><span class="p">)</span>
<span class="gp">... </span><span class="k">except</span> <span class="ne">OSError</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">pass</span>  <span class="c"># this can sometimes fail under Windows</span>
</pre></div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Working with numerical data in shared memory (memmaping)</a><ul>
<li><a class="reference internal" href="#automated-array-to-memmap-conversion">Automated array to memmap conversion</a></li>
<li><a class="reference internal" href="#manual-management-of-memmaped-input-data">Manual management of memmaped input data</a></li>
<li><a class="reference internal" href="#writing-parallel-computation-results-in-shared-memory">Writing parallel computation results in shared memory</a></li>
</ul>
</li>
</ul>


    <hr/>

<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
    <hr/>
    <div>
	<h3>Mailing list</h3>
	<a href="http://librelist.com/browser/joblib/">joblib@librelist.com</a>
    <p class="searchtip" style="font-size: 80%">
    Send an email to subscribe</p>
    </div>
<hr/>
<small><a href="_sources/parallel_numpy.txt"
           rel="nofollow">Show this page source</a>
</small>

        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="index.html">joblib 0.9.0.dev0 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2008-2009, Gael Varoquaux.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.3.
    </div>
  </body>
</html>