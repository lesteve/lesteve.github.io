<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>On demand recomputing: the Memory class &mdash; joblib 0.9.0.dev0 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.9.0.dev0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="joblib 0.9.0.dev0 documentation" href="index.html" />
    <link rel="next" title="Embarrassingly parallel for loops" href="parallel.html" />
    <link rel="prev" title="Installing joblib" href="installing.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="parallel.html" title="Embarrassingly parallel for loops"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="installing.html" title="Installing joblib"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">joblib 0.9.0.dev0 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="on-demand-recomputing-the-memory-class">
<span id="memory"></span><h1>On demand recomputing: the <cite>Memory</cite> class<a class="headerlink" href="#on-demand-recomputing-the-memory-class" title="Permalink to this headline">¶</a></h1>
<div class="section" id="usecase">
<h2>Usecase<a class="headerlink" href="#usecase" title="Permalink to this headline">¶</a></h2>
<p>The <cite>Memory</cite> class defines a context for lazy evaluation of function, by
storing the results to the disk, and not rerunning the function twice for
the same arguments.</p>
<p>It works by explicitly saving the output to a file and it is designed to
work with non-hashable and potentially large input and output data types
such as numpy arrays.</p>
<div class="section" id="a-simple-example">
<h3>A simple example:<a class="headerlink" href="#a-simple-example" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>First we create a temporary directory, for the cache:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">tempfile</span> <span class="kn">import</span> <span class="n">mkdtemp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cachedir</span> <span class="o">=</span> <span class="n">mkdtemp</span><span class="p">()</span>
</pre></div>
</div>
<p>We can instantiate a memory context, using this cache directory:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">joblib</span> <span class="kn">import</span> <span class="n">Memory</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">memory</span> <span class="o">=</span> <span class="n">Memory</span><span class="p">(</span><span class="n">cachedir</span><span class="o">=</span><span class="n">cachedir</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>Then we can decorate a function to be cached in this context:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nd">@memory.cache</span>
<span class="gp">... </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="s">&#39;Running f(</span><span class="si">%s</span><span class="s">)&#39;</span> <span class="o">%</span> <span class="n">x</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">x</span>
</pre></div>
</div>
<p>When we call this function twice with the same argument, it does not
get executed the second time, and the output gets loaded from the pickle
file:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="go">Running f(1)</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="go">1</span>
</pre></div>
</div>
<p>However, when we call it a third time, with a different argument, the
output gets recomputed:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="go">Running f(2)</span>
<span class="go">2</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="comparison-with-memoize">
<h3>Comparison with <cite>memoize</cite><a class="headerlink" href="#comparison-with-memoize" title="Permalink to this headline">¶</a></h3>
<p>The <cite>memoize</cite> decorator (<a class="reference external" href="http://code.activestate.com/recipes/52201/">http://code.activestate.com/recipes/52201/</a>)
caches in memory all the inputs and outputs of a function call. It can
thus avoid running twice the same function, with a very small
overhead. However, it compares input objects with those in cache on each
call. As a result, for big objects there is a huge overhead. Moreover
this approach does not work with numpy arrays, or other objects subject
to non-significant fluctuations. Finally, using <cite>memoize</cite> with large
objects will consume all the memory, where with <cite>Memory</cite>, objects are
persisted to disk, using a persister optimized for speed and memory
usage (<a class="reference internal" href="generated/joblib.dump.html#joblib.dump" title="joblib.dump"><tt class="xref py py-func docutils literal"><span class="pre">joblib.dump()</span></tt></a>).</p>
<p>In short, <cite>memoize</cite> is best suited for functions with &#8220;small&#8221; input and
output objects, whereas <cite>Memory</cite> is best suited for functions with complex
input and output objects, and aggressive persistence to disk.</p>
</div>
</div>
<div class="section" id="using-with-numpy">
<h2>Using with <cite>numpy</cite><a class="headerlink" href="#using-with-numpy" title="Permalink to this headline">¶</a></h2>
<p>The original motivation behind the <cite>Memory</cite> context was to be able to a
memoize-like pattern on numpy arrays. <cite>Memory</cite> uses fast cryptographic
hashing of the input arguments to check if they have been computed;</p>
<div class="section" id="an-example">
<h3>An example<a class="headerlink" href="#an-example" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>We define two functions, the first with a number as an argument,
outputting an array, used by the second one. We decorate both
functions with <cite>Memory.cache</cite>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="gp">&gt;&gt;&gt; </span><span class="nd">@memory.cache</span>
<span class="gp">... </span><span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="s">&#39;A long-running calculation, with parameter </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">x</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">hamming</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="nd">@memory.cache</span>
<span class="gp">... </span><span class="k">def</span> <span class="nf">h</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="s">&#39;A second long-running calculation, using g(x)&#39;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vander</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>If we call the function h with the array created by the same call to g,
h is not re-run:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">g</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">A long-running calculation, with parameter 3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([ 0.08,  1.  ,  0.08])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">array([ 0.08,  1.  ,  0.08])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">h</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">A second long-running calculation, using g(x)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b2</span> <span class="o">=</span> <span class="n">h</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b2</span>
<span class="go">array([[ 0.0064,  0.08  ,  1.    ],</span>
<span class="go">       [ 1.    ,  1.    ,  1.    ],</span>
<span class="go">       [ 0.0064,  0.08  ,  1.    ]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">b2</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="using-memmapping">
<h3>Using memmapping<a class="headerlink" href="#using-memmapping" title="Permalink to this headline">¶</a></h3>
<p>To speed up cache looking of large numpy arrays, you can load them
using memmapping (memory mapping):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">cachedir2</span> <span class="o">=</span> <span class="n">mkdtemp</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">memory2</span> <span class="o">=</span> <span class="n">Memory</span><span class="p">(</span><span class="n">cachedir</span><span class="o">=</span><span class="n">cachedir2</span><span class="p">,</span> <span class="n">mmap_mode</span><span class="o">=</span><span class="s">&#39;r&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span> <span class="o">=</span> <span class="n">memory2</span><span class="o">.</span><span class="n">cache</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vander</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">________________________________________________________________________________</span>
<span class="go">[Memory] Calling square...</span>
<span class="go">square(array([[ 0.,  0.,  1.],</span>
<span class="go">       [ 1.,  1.,  1.],</span>
<span class="go">       [ 4.,  2.,  1.]]))</span>
<span class="go">___________________________________________________________square - 0.0s, 0.0min</span>
<span class="go">memmap([[  0.,   0.,   1.],</span>
<span class="go">       [  1.,   1.,   1.],</span>
<span class="go">       [ 16.,   4.,   1.]])</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Notice the debug mode used in the above example. It is useful for
tracing of what is being reexecuted, and where the time is spent.</p>
</div>
<p>If the <cite>square</cite> function is called with the same input argument, its
return value is loaded from the disk using memmapping:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">square</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">res</span><span class="p">))</span>
<span class="go">memmap([[  0.,   0.,   1.],</span>
<span class="go">       [  1.,   1.,   1.],</span>
<span class="go">       [ 16.,   4.,   1.]])</span>
</pre></div>
</div>
<blockquote>
<div><p>We need to close the memmap file to avoid file locking on Windows; closing
numpy.memmap objects is done with del, which flushes changes to the disk</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">res</span>
</pre></div>
</div>
</div></blockquote>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>If the memory mapping mode used was &#8216;r&#8217;, as in the above example, the
array will be read only, and will be impossible to modified in place.</p>
<p class="last">On the other hand, using &#8216;r+&#8217; or &#8216;w+&#8217; will enable modification of the
array, but will propagate these modification to the disk, which will
corrupt the cache. If you want modification of the array in memory, we
suggest you use the &#8216;c&#8217; mode: copy on write.</p>
</div>
</div>
</div>
<div class="section" id="shelving-using-references-to-cached-values">
<h2>Shelving: using references to cached values<a class="headerlink" href="#shelving-using-references-to-cached-values" title="Permalink to this headline">¶</a></h2>
<p>In some cases, it can be useful to get a reference to the cached
result, instead of having the result itself. A typical example of this
is when a lot of large numpy arrays must be dispatched accross several
workers: instead of sending the data themselves over the network, send
a reference to the joblib cache, and let the workers read the data
from a network filesystem, potentially taking advantage of some
system-level caching too.</p>
<p>Getting a reference to the cache can be done using the
<cite>call_and_shelve</cite> method on the wrapped function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">call_and_shelve</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">A long-running calculation, with parameter 4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span>  
<span class="go">MemorizedResult(cachedir=&quot;...&quot;, func=&quot;g...&quot;, argument_hash=&quot;...&quot;)</span>
</pre></div>
</div>
<p>Once computed, the output of <cite>g</cite> is stored on disk, and deleted from
memory. Reading the associated value can then be performed with the
<cite>get</cite> method:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">result</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
<span class="go">array([ 0.08,  0.77,  0.77,  0.08])</span>
</pre></div>
</div>
<p>The cache for this particular value can be cleared using the <cite>clear</cite>
method. Its invocation causes the stored value to be erased from disk.
Any subsequent call to <cite>get</cite> will cause a <cite>KeyError</cite> exception to be
raised:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">result</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>  
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">KeyError</span>: <span class="n">&#39;Non-existing cache value (may have been cleared).\nFile ... does not exist&#39;</span>
</pre></div>
</div>
<p>A <cite>MemorizedResult</cite> instance contains all that is necessary to read
the cached value. It can be pickled for transmission or storage, and
the printed representation can even be copy-pasted to a different
python interpreter.</p>
<div class="topic">
<p class="topic-title first">Shelving when cache is disabled</p>
<p>In the case where caching is disabled (e.g.
<cite>Memory(cachedir=None)</cite>), the <cite>call_and_shelve</cite> method returns a
<cite>NotMemorizedResult</cite> instance, that stores the full function
output, instead of just a reference (since there is nothing to
point to). All the above remains valid though, except for the
copy-pasting feature.</p>
</div>
</div>
<div class="section" id="gotchas">
<h2>Gotchas<a class="headerlink" href="#gotchas" title="Permalink to this headline">¶</a></h2>
<ul>
<li><p class="first"><strong>Across sessions, function cache is identified by the function&#8217;s name</strong>.
Thus if you have the same name to different functions, their cache will
override each-others (you have &#8216;name collisions&#8217;), and you will get
unwanted re-run:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nd">@memory.cache</span>
<span class="gp">... </span><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="s">&#39;Running func(</span><span class="si">%s</span><span class="s">)&#39;</span> <span class="o">%</span> <span class="n">x</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">func2</span> <span class="o">=</span> <span class="n">func</span>

<span class="gp">&gt;&gt;&gt; </span><span class="nd">@memory.cache</span>
<span class="gp">... </span><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="s">&#39;Running a different func(</span><span class="si">%s</span><span class="s">)&#39;</span> <span class="o">%</span> <span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>As long as you stay in the same session, there are no collisions (in joblib
0.8 and above), altough joblib does warn you that you are doing something
dangerous:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">func</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">Running a different func(1)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">func2</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">memory.rst:0: JobLibCollisionWarning: Possible name collisions between functions &#39;func&#39; (&lt;doctest memory.rst&gt;:...) and &#39;func&#39; (&lt;doctest memory.rst&gt;:...)</span>
<span class="go">Running func(1)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">func</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c"># No recomputation so far</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">func2</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c"># No recomputation so far</span>
</pre></div>
</div>
<p>But suppose you exit the interpreter and restart it, the cache will not
be identified properly, and the functions will be rerun:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">func</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> 
<span class="go">memory.rst:0: JobLibCollisionWarning: Possible name collisions between functions &#39;func&#39; (&lt;doctest memory.rst&gt;:...) and &#39;func&#39; (&lt;doctest memory.rst&gt;:...)</span>
<span class="go">Running a different func(1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">func2</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">Running func(1)</span>
</pre></div>
</div>
<p>As long as you stay in the same session, you are not getting needless
recomputation:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">func</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c"># No recomputation now</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">func2</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c"># No recomputation now</span>
</pre></div>
</div>
</li>
<li><p class="first"><strong>lambda functions</strong></p>
<p>Beware that with Python 2.6 lambda functions cannot be separated out:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">my_print</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">memory</span><span class="o">.</span><span class="n">cache</span><span class="p">(</span><span class="k">lambda</span> <span class="p">:</span> <span class="n">my_print</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">memory</span><span class="o">.</span><span class="n">cache</span><span class="p">(</span><span class="k">lambda</span> <span class="p">:</span> <span class="n">my_print</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="p">()</span> 
<span class="go">memory.rst:0: JobLibCollisionWarning: Cannot detect name collisions for function &#39;&lt;lambda&gt;&#39;</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="p">()</span> 
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">()</span> 
<span class="go">1</span>
</pre></div>
</div>
</li>
<li><p class="first"><strong>memory cannot be used on some complex objects</strong>, e.g. a callable
object with a <cite>__call__</cite> method.</p>
<p>However, it works on numpy ufuncs:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">sin</span> <span class="o">=</span> <span class="n">memory</span><span class="o">.</span><span class="n">cache</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="go">0.0</span>
</pre></div>
</div>
</li>
<li><p class="first"><strong>caching methods</strong>: you cannot decorate a method at class definition,
because when the class is instantiated, the first argument (self) is
<em>bound</em>, and no longer accessible to the <cite>Memory</cite> object. The following
code won&#8217;t work:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Foo</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="nd">@mem.cache</span>  <span class="c"># WRONG</span>
    <span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="k">pass</span>
</pre></div>
</div>
<p>The right way to do this is to decorate at instantiation time:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Foo</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">=</span> <span class="n">mem</span><span class="o">.</span><span class="n">cache</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">...</span><span class="p">):</span>
        <span class="k">pass</span>
</pre></div>
</div>
</li>
</ul>
</div>
<div class="section" id="ignoring-some-arguments">
<h2>Ignoring some arguments<a class="headerlink" href="#ignoring-some-arguments" title="Permalink to this headline">¶</a></h2>
<p>It may be useful not to recalculate a function when certain arguments
change, for instance a debug flag. <cite>Memory</cite> provides the <cite>ignore</cite> list:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nd">@memory.cache</span><span class="p">(</span><span class="n">ignore</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;debug&#39;</span><span class="p">])</span>
<span class="gp">... </span><span class="k">def</span> <span class="nf">my_func</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="s">&#39;Called with x = </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">my_func</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">Called with x = 0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">my_func</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">my_func</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># my_func was not reevaluated</span>
</pre></div>
</div>
</div>
<div class="section" id="reference-documentation-of-the-memory-class">
<span id="memory-reference"></span><h2>Reference documentation of the <cite>Memory</cite> class<a class="headerlink" href="#reference-documentation-of-the-memory-class" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="joblib.memory.Memory">
<em class="property">class </em><tt class="descclassname">joblib.memory.</tt><tt class="descname">Memory</tt><big>(</big><em>cachedir</em>, <em>mmap_mode=None</em>, <em>compress=False</em>, <em>verbose=1</em><big>)</big><a class="headerlink" href="#joblib.memory.Memory" title="Permalink to this definition">¶</a></dt>
<dd><p>A context object for caching a function&#8217;s return value each time it
is called with the same input arguments.</p>
<p>All values are cached on the filesystem, in a deep directory
structure.</p>
<p>see <a class="reference internal" href="#memory-reference"><em>Reference documentation of the Memory class</em></a></p>
<dl class="method">
<dt id="joblib.memory.Memory.__init__">
<tt class="descname">__init__</tt><big>(</big><em>cachedir</em>, <em>mmap_mode=None</em>, <em>compress=False</em>, <em>verbose=1</em><big>)</big><a class="headerlink" href="#joblib.memory.Memory.__init__" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>cachedir: string or None</strong> :</p>
<blockquote>
<div><p>The path of the base directory to use as a data store
or None. If None is given, no caching is done and
the Memory object is completely transparent.</p>
</div></blockquote>
<p><strong>mmap_mode: {None, &#8216;r+&#8217;, &#8216;r&#8217;, &#8216;w+&#8217;, &#8216;c&#8217;}, optional</strong> :</p>
<blockquote>
<div><p>The memmapping mode used when loading from cache
numpy arrays. See numpy.load for the meaning of the
arguments.</p>
</div></blockquote>
<p><strong>compress: boolean, or integer</strong> :</p>
<blockquote>
<div><p>Whether to zip the stored data on disk. If an integer is
given, it should be between 1 and 9, and sets the amount
of compression. Note that compressed arrays cannot be
read by memmapping.</p>
</div></blockquote>
<p><strong>verbose: int, optional</strong> :</p>
<blockquote class="last">
<div><p>Verbosity flag, controls the debug messages that are issued
as functions are evaluated.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="joblib.memory.Memory.cache">
<tt class="descname">cache</tt><big>(</big><em>func=None</em>, <em>ignore=None</em>, <em>verbose=None</em>, <em>mmap_mode=False</em><big>)</big><a class="headerlink" href="#joblib.memory.Memory.cache" title="Permalink to this definition">¶</a></dt>
<dd><p>Decorates the given function func to only compute its return
value for input arguments not cached on disk.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>func: callable, optional</strong> :</p>
<blockquote>
<div><p>The function to be decorated</p>
</div></blockquote>
<p><strong>ignore: list of strings</strong> :</p>
<blockquote>
<div><p>A list of arguments name to ignore in the hashing</p>
</div></blockquote>
<p><strong>verbose: integer, optional</strong> :</p>
<blockquote>
<div><p>The verbosity mode of the function. By default that
of the memory object is used.</p>
</div></blockquote>
<p><strong>mmap_mode: {None, &#8216;r+&#8217;, &#8216;r&#8217;, &#8216;w+&#8217;, &#8216;c&#8217;}, optional</strong> :</p>
<blockquote>
<div><p>The memmapping mode used when loading from cache
numpy arrays. See numpy.load for the meaning of the
arguments. By default that of the memory object is used.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>decorated_func: MemorizedFunc object</strong> :</p>
<blockquote class="last">
<div><p>The returned object is a MemorizedFunc object, that is
callable (behaves like a function), but offers extra
methods for cache lookup and management. See the
documentation for <a class="reference internal" href="#joblib.memory.MemorizedFunc" title="joblib.memory.MemorizedFunc"><tt class="xref py py-class docutils literal"><span class="pre">joblib.memory.MemorizedFunc</span></tt></a>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="joblib.memory.Memory.clear">
<tt class="descname">clear</tt><big>(</big><em>warn=True</em><big>)</big><a class="headerlink" href="#joblib.memory.Memory.clear" title="Permalink to this definition">¶</a></dt>
<dd><p>Erase the complete cache directory.</p>
</dd></dl>

<dl class="method">
<dt id="joblib.memory.Memory.eval">
<tt class="descname">eval</tt><big>(</big><em>func</em>, <em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#joblib.memory.Memory.eval" title="Permalink to this definition">¶</a></dt>
<dd><p>Eval function func with arguments <cite>*args</cite> and <cite>**kwargs</cite>,
in the context of the memory.</p>
<p>This method works similarly to the builtin <cite>apply</cite>, except
that the function is called only if the cache is not
up to date.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="useful-methods-of-decorated-functions">
<h2>Useful methods of decorated functions<a class="headerlink" href="#useful-methods-of-decorated-functions" title="Permalink to this headline">¶</a></h2>
<p>Function decorated by <a class="reference internal" href="#joblib.memory.Memory.cache" title="joblib.memory.Memory.cache"><tt class="xref py py-meth docutils literal"><span class="pre">Memory.cache()</span></tt></a> are <a class="reference internal" href="#joblib.memory.MemorizedFunc" title="joblib.memory.MemorizedFunc"><tt class="xref py py-class docutils literal"><span class="pre">MemorizedFunc</span></tt></a>
objects that, in addition of behaving like normal functions, expose
methods useful for cache exploration and management.</p>
<dl class="class">
<dt id="joblib.memory.MemorizedFunc">
<em class="property">class </em><tt class="descclassname">joblib.memory.</tt><tt class="descname">MemorizedFunc</tt><big>(</big><em>func</em>, <em>cachedir</em>, <em>ignore=None</em>, <em>mmap_mode=None</em>, <em>compress=False</em>, <em>verbose=1</em>, <em>timestamp=None</em><big>)</big><a class="headerlink" href="#joblib.memory.MemorizedFunc" title="Permalink to this definition">¶</a></dt>
<dd><p>Callable object decorating a function for caching its return value
each time it is called.</p>
<p>All values are cached on the filesystem, in a deep directory
structure. Methods are provided to inspect the cache or clean it.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><p class="first"><strong>func: callable</strong> :</p>
<blockquote>
<div><p>The original, undecorated, function.</p>
</div></blockquote>
<p><strong>cachedir: string</strong> :</p>
<blockquote>
<div><p>Path to the base cache directory of the memory context.</p>
</div></blockquote>
<p><strong>ignore: list or None</strong> :</p>
<blockquote>
<div><p>List of variable names to ignore when choosing whether to
recompute.</p>
</div></blockquote>
<p><strong>mmap_mode: {None, &#8216;r+&#8217;, &#8216;r&#8217;, &#8216;w+&#8217;, &#8216;c&#8217;}</strong> :</p>
<blockquote>
<div><p>The memmapping mode used when loading from cache
numpy arrays. See numpy.load for the meaning of the different
values.</p>
</div></blockquote>
<p><strong>compress: boolean, or integer</strong> :</p>
<blockquote>
<div><p>Whether to zip the stored data on disk. If an integer is
given, it should be between 1 and 9, and sets the amount
of compression. Note that compressed arrays cannot be
read by memmapping.</p>
</div></blockquote>
<p><strong>verbose: int, optional</strong> :</p>
<blockquote class="last">
<div><p>The verbosity flag, controls messages that are issued as
the function is evaluated.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="joblib.memory.MemorizedFunc.__init__">
<tt class="descname">__init__</tt><big>(</big><em>func</em>, <em>cachedir</em>, <em>ignore=None</em>, <em>mmap_mode=None</em>, <em>compress=False</em>, <em>verbose=1</em>, <em>timestamp=None</em><big>)</big><a class="headerlink" href="#joblib.memory.MemorizedFunc.__init__" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>func: callable</strong> :</p>
<blockquote>
<div><p>The function to decorate</p>
</div></blockquote>
<p><strong>cachedir: string</strong> :</p>
<blockquote>
<div><p>The path of the base directory to use as a data store</p>
</div></blockquote>
<p><strong>ignore: list or None</strong> :</p>
<blockquote>
<div><p>List of variable names to ignore.</p>
</div></blockquote>
<p><strong>mmap_mode: {None, &#8216;r+&#8217;, &#8216;r&#8217;, &#8216;w+&#8217;, &#8216;c&#8217;}, optional</strong> :</p>
<blockquote>
<div><p>The memmapping mode used when loading from cache
numpy arrays. See numpy.load for the meaning of the
arguments.</p>
</div></blockquote>
<p><strong>compress</strong> : boolean, or integer</p>
<blockquote>
<div><p>Whether to zip the stored data on disk. If an integer is
given, it should be between 1 and 9, and sets the amount
of compression. Note that compressed arrays cannot be
read by memmapping.</p>
</div></blockquote>
<p><strong>verbose: int, optional</strong> :</p>
<blockquote>
<div><p>Verbosity flag, controls the debug messages that are issued
as functions are evaluated. The higher, the more verbose</p>
</div></blockquote>
<p><strong>timestamp: float, optional</strong> :</p>
<blockquote class="last">
<div><p>The reference time from which times in tracing messages
are reported.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="joblib.memory.MemorizedFunc.call">
<tt class="descname">call</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#joblib.memory.MemorizedFunc.call" title="Permalink to this definition">¶</a></dt>
<dd><p>Force the execution of the function with the given arguments and
persist the output values.</p>
</dd></dl>

<dl class="method">
<dt id="joblib.memory.MemorizedFunc.clear">
<tt class="descname">clear</tt><big>(</big><em>warn=True</em><big>)</big><a class="headerlink" href="#joblib.memory.MemorizedFunc.clear" title="Permalink to this definition">¶</a></dt>
<dd><p>Empty the function&#8217;s cache.</p>
</dd></dl>

<dl class="method">
<dt id="joblib.memory.MemorizedFunc.get_output_dir">
<tt class="descname">get_output_dir</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#joblib.memory.MemorizedFunc.get_output_dir" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the directory in which are persisted the result
of the function called with the given arguments.</p>
</dd></dl>

<dl class="method">
<dt id="joblib.memory.MemorizedFunc.load_output">
<tt class="descname">load_output</tt><big>(</big><em>output_dir</em><big>)</big><a class="headerlink" href="#joblib.memory.MemorizedFunc.load_output" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the results of a previous calculation from the directory
it was cached in.</p>
</dd></dl>

</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">On demand recomputing: the <cite>Memory</cite> class</a><ul>
<li><a class="reference internal" href="#usecase">Usecase</a><ul>
<li><a class="reference internal" href="#a-simple-example">A simple example:</a></li>
<li><a class="reference internal" href="#comparison-with-memoize">Comparison with <cite>memoize</cite></a></li>
</ul>
</li>
<li><a class="reference internal" href="#using-with-numpy">Using with <cite>numpy</cite></a><ul>
<li><a class="reference internal" href="#an-example">An example</a></li>
<li><a class="reference internal" href="#using-memmapping">Using memmapping</a></li>
</ul>
</li>
<li><a class="reference internal" href="#shelving-using-references-to-cached-values">Shelving: using references to cached values</a></li>
<li><a class="reference internal" href="#gotchas">Gotchas</a></li>
<li><a class="reference internal" href="#ignoring-some-arguments">Ignoring some arguments</a></li>
<li><a class="reference internal" href="#reference-documentation-of-the-memory-class">Reference documentation of the <cite>Memory</cite> class</a></li>
<li><a class="reference internal" href="#useful-methods-of-decorated-functions">Useful methods of decorated functions</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="installing.html"
                        title="previous chapter">Installing joblib</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="parallel.html"
                        title="next chapter">Embarrassingly parallel for loops</a></p>

    <hr/>

<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
    <hr/>
    <div>
	<h3>Mailing list</h3>
	<a href="http://librelist.com/browser/joblib/">joblib@librelist.com</a>
    <p class="searchtip" style="font-size: 80%">
    Send an email to subscribe</p>
    </div>
<hr/>
<small><a href="_sources/memory.txt"
           rel="nofollow">Show this page source</a>
</small>

        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="parallel.html" title="Embarrassingly parallel for loops"
             >next</a> |</li>
        <li class="right" >
          <a href="installing.html" title="Installing joblib"
             >previous</a> |</li>
        <li><a href="index.html">joblib 0.9.0.dev0 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2008-2009, Gael Varoquaux.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.3.
    </div>
  </body>
</html>